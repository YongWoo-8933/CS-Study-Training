sorting(정렬): 데이터 집합을 일정한 순서로 바꾸어 늘어놓는 작업
-> ascending(오름차순) / descending(내림차순)

'안정적인' 정렬 알고리즘: 값이 같은 원소의 순서가 정렬 후에도 유지되는 알고리즘

internal sorting(내부정렬): 정렬할 모든 데이터를 하나의 배열에 저장할 수 있는 정렬 알고리즘
external sorting(외부정렬): 정렬할 데이터가 많아 하나의 배열에 저장할 수 없는 정렬 알고리즘

bubble sorting(버블정렬)=단순교환정렬: 이웃한 두원소의 대소관계를 비교하며 교환을 반복하는 알고리즘
-> 안정적인 정렬 알고리즘, 시간 복잡도 O(n^2)

straight selection sorting(단순선택정렬): 가장 작은 원소부터 선택해 알맞은 위치로 옮기는 작업을 반복하는 알고리즘
-> 불안정적인 정렬 알고리즘, 시간 복잡도 O(n^2)

straight insertion sorting(단순삽입정렬): 주목한 원소보다 더 앞쪽에서 알맞은 위치로 삽입하며 정렬하는 알고리즘
-> 안정적인 정렬 알고리즘, 시간 복잡도 O(n^2)

=========================================================================================================================================

shell sorting(셸 정렬): 단순 삽입 정렬의 방법을 유지하되, h값으로 배열의 원소들을 grouping해 각 그룹별로 단순 삽입 정렬하는 것을 반복하는 알고리즘
-> 불안정적인 정렬 알고리즘, 퀵정렬 고안 전까지 가장 빨랐던 알고리즘, 시간 복잡도 O(n^1.25)

quick sorting(퀵 정렬): pivot을 기준으로 배열을 grouping하여, 모든 group이 1개의 원소가 될때까지 반복하는 알고리즘
-> 불안정적인 정렬 알고리즘, 가장 빠른 정렬 알고리즘으로 알려져 있음, 시간 복잡도 O(nlogn)

merge sort(병합 정렬): 배열을 앞/뒤 두그룹으로 나누어 각각 정렬한 후 병합하는 작업을 반복하는 알고리즘
-> 안정적인 정렬 알고리즘, 시간 복잡도 O(nlogn)

heap(힙)=partial ordered tree(부분 순서 트리): '부모의 값이 자식의 값보다 항상 크다(작다)'는 조건을 만족하는 완전 이진트리
-> 형제 간 대소관계는 정해져 있지 않음
-> index를 매길땐 부모->자식 순, 왼쪽->오른쪽 자식 순으로 매김
-> 따라서 a[i]의 주변 원소는 다음 관계를 가짐
-> 부모: a[(i-1)//2], 왼쪽 자식: a[2*i+1], 오른쪽 자식: a[2*i+2]
-> 힙에서 최댓값은 루트에 위치한다
heap sort(힙 정렬): 선택 정렬을 응용한 알고리즘으로, 힙의 루트를 꺼내고 나머지를 다시 힙으로 만드는 과정을 반복하는 알고리즘
-> 불안정적인 정렬 알고리즘, 시간 복잡도 O(nlogn)

counting sort(도수 정렬)=distribution counting(분포수 세기): 원소의 대소 관계를 판단하지 않고 빠르게 정렬하는 알고리즘
-> 도수분포표의 원리를 활용해서 정렬
-> 원소를 비교할 필요가 없음
-> if문을 사용하지 않고 for문만 반복해서 정렬할 수 있음
-> 로직을 제대로 구현하면 안정적인 정렬 알고리즘, 시간/공간 복잡도 O(n)이지만 최대-최소값을 알고 있어야함